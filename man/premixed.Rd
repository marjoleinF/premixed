% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/premixed.R
\name{premixed}
\alias{premixed}
\title{Fitting a prediction rule ensemble with clustered data}
\usage{
premixed(formula, cluster = NULL, data, penalty.par.val = "lambda.min",
  learnrate = 0, use.grad = FALSE, conv.thresh = 0.01,
  family = "gaussian", ridge.ranef = FALSE, max.iter = 1000, ...)
}
\arguments{
\item{formula}{a formula with three-part right-hand side, like 
\code{y ~ 1 | cluster | x1 + x2 + x3}; or with one-part right hand side, like
\code{y ~ x1 + x2 + x3}. In the latter case, the cluster indicator must
be specified through the \code{cluster} argument.
#' @param data a dataframe containing the variables in the model}

\item{cluster}{optional character string supplying the name of the cluster 
indicator. If specified, \code{formula} should not involve random effects 
(e.g., \code{y ~ x1+ x2 + x3}). If \code{cluster} is specified, random 
effects will not be estimated during tree induction. This will substantially 
speed up computations, but may yield a less accurate model, depending on the 
magnitude of the random effects.}

\item{data}{dataframe containing the variables specified in \code{formula}.}

\item{penalty.par.val}{as usual.}

\item{learnrate}{as usual.}

\item{use.grad}{as usual.}

\item{conv.thresh}{numeric vector of length 1, specifies the convergence
criterion. The algorithm converges if the maximum absolute difference in 
random-effects predictions from one iteration is smaller than 
\code{conv.thresh}.}

\item{family}{as usual. Note: should be a character vector!}

\item{ridge.ranef}{logical vector of length 1. Should random effects be
estimated through a ridge regression? If set to \code{TRUE}, random effects 
will be estimated through fitting a ridge regression model using function 
\code{\link[glmnet]{cv.glmnet}}. If set to \code{FALSE}, random
effects will be estimated through fitting a mixed-effects regression model
using function \code{\link[lme4]{lmer}} or \code{\link[lme4]{glmer}}.}

\item{max.iter}{numeric vector of length 1. Maximum number of iterations
performed to re-estimate fixed and random effects parameters.}

\item{...}{further arguments to be passed to \code{\link[pre]{pre}}.}
}
\value{
An object of class 'premixed'.
}
\description{
Experimental function for fitting mixed-effects prediction rule
ensembles. Estimates a random intercept in addition to a prediction rule 
ensemble. This allows for analysing datasets with a clustered or multilevel
structure, or longitudinal datasets. Experimental, so use at own risk. 

Function premixed() allows for taking into account a random intercept in I) 
rule induction and/or II) coefficient estimation. To take into account the 
random intercept in both rule induction and coefficient estimation, see 
Example 1 below. To take into account the random intercept only in 
coefficient estimation, see Example 2 below. Alternatively, it has been 
suggested that random effects do not need to be taken into account
explicitly but only through employing a blocked bootstrap or subampling 
approach, see Exemple 3 below. Note that approaches / examples 1 and 2 can 
be combined with the third approach / example 3. See Example 4 below. 

Note that random intercept-only models are currently supported. That is, 
random slopes can currently not be specified.
}
\details{
\code{premixed} is a wrapper for fitting a PRe with clustered data
}
\examples{
\donttest{

## Example 1: Take into account clustered structure in rule induction
## as well as coeficient estimation: 
set.seed(42)
airq <- airquality[complete.cases(airquality),]
airq.ens1 <- premixed(Ozone ~ 1 | Month | Solar.R + Wind + Temp + Day, data = airq, ntrees = 10)
airq.ens1


## Example 2: Take into account clustered stucture in coefficient estimation
## only:
set.seed(42)
airq <- airquality[complete.cases(airquality),]
airq.ens1 <- premixed(Ozone ~ 1 | Month | Solar.R + Wind + Temp + Day, data = airq, ntrees = 10)
airq.ens1




## First create a sampling function that bootstrap samples whole clusters:
bb_sampfunc <- function(cluster = airq$Month) {
  result <- c()
  for(i in sample(unique(cluster), replace = TRUE)) {
    result <- c(result, which(cluster == i))
  }
  result
}
## And then fit the PRE:
library(pre)
set.seed(42)
airq.ens3 <- pre(Ozone ~ ., data = airq, sampfrac = bb_sampfunc)
airq.ens3


## Employ ctree with blocked subsampling for rule induction:
##
## First create a function that creates subsamples containing ~75\% of the clusters: 
ss_sampfunc <- function(cluster = airq$Month, sampfrac = .75) {
  result <- c()
  n_clusters <- round(length(unique(cluster)) * sampfrac)
  for(i in sample(unique(cluster), size = n_clusters, replace = FALSE)) {
    result <- c(result, which(cluster == i))
  }
  result
}
## And then fit the PRE:
library(pre)
set.seed(42)
airq.ens4 <- pre(Ozone ~ ., data = airq, sampfrac = ss_sampfunc)
airq.ens4


## Employ ctree with blocked bootstrapsampling for rule inducation,
## and include random effects only in estimation of the final ensemble:
bb_sampfunc <- function(cluster = airq$Month) {
  result <- c()
  for(i in sample(unique(cluster), replace = TRUE)) {
    result <- c(result, which(cluster == i))
  }
  result
}
set.seed(42)
airq.ens5 <- premixed(Ozone ~ Solar.R + Wind + Temp + Day, cluster = "Month", 
  data = airq, sampfrac = bb_sampfunc)
airq.ens5

}   
}
